
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Blog Bom!!BO!">
    <title>Java Reference Object - Blog Bom!!BO!</title>
    <meta name="author" content="Eddie Lee">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Eddie Lee","sameAs":["https://github.com/RadianceL"],"image":"eddie-personal.jpg"},"articleBody":"References and ReferentsA reference object is a layer of indirection between your program code and some other object, called a referent. Each reference object is constructed around its referent, and the referent cannot be changed.\n—Keith D Gregory\n初学Java时，在很长一段时间里，总觉得基本概念很模糊。后来才知道，在许多Java书中，把对象和对象的引用混为一谈。可是，如果我分不清对象与对象引用，那实在没法很好地理解下面的面向对象技术。把自己的一点认识写下来，或许能让初学Java的朋友们少走一点弯路。为便于说明，我们先定义一个简单的类：12345class Vehicle &#123;\tint passengers;      \tint fuelcap;\tint mpg;\t&#125;\n有了这个模板，就可以用它来创建对象：1Vehicle veh1 = new Vehicle();\n通常把这条语句的动作称之为创建一个对象，其实，它包含了四个动作.\n\n右边的new Vehicle，是以Vehicle类为模板，在堆空间里创建一个Vehicle类对象（也简称为Vehicle对象）。\n末尾的()意味着，在对象创建后，立即调用Vehicle类的构造函数，对刚生成的对象进行初始化。构造函数是肯定有的。如果你没写，Java会给你补上一个默认的构造函数。\n左边的Vehicle veh 1创建了一个Vehicle类引用变量。所谓Vehicle类引用，就是以后可以用来指向Vehicle对象的对象引用。\n“=”操作符使对象引用指向刚创建的那个Vehicle对象。\n\n我们可以把这条语句拆成两部分:\n12Vehicle veh1;veh1 = new Vehicle();\n效果是一样的。这样写，就比较清楚了，有两个实体：一是对象引用变量，一是对象本身。在堆空间里创建的实体，与在数据段以及栈空间里创建的实体不同。尽管它们也是确确实实存在的实体，但是，我们看不见，也摸不着。不仅如此，我们仔细研究一下第二句，找找刚创建的对象叫什么名字？有人说，它叫Vehicle。不对，Vehicle是类（对象的创建模板）的名字。\n一个Vehicle类可以据此创建出无数个对象，这些对象不可能全叫Vehicle。对象连名都没有，没法直接访问它。我们只能通过对象引用来间接访问对象。为了形象地说明对象、引用及它们之间的关系，可以做一个或许不很妥当的比喻。对象好比是一只很大的气球，大到我们抓不住它。引用变量是一根绳， 可以用来系汽球。如果只执行了第一条语句，还没执行第二条，此时创建的引用变量veh1还没指向任何一个对象，它的值是null。引用变量可以指向某个对象，或者为null\n它是一根绳，一根还没有系上任何一个汽球的绳。执行了第二句后，一只新汽球做出来了，并被系在veh1这根绳上。我们抓住这根绳，就等于抓住了那只汽球。再来一句:\n1Vehicle veh2;\n就又做了一根绳，还没系上汽球。如果再加一句:\n1veh2 = veh1;\n系上了。这里，发生了复制行为。但是，要说明的是，对象本身并没有被复制，被复制的只是对象引用。结果是，veh2也指向了veh1所指向的对象。两根绳系的是同一只汽球。如果用下句再创建一个对象:\n1veh2 = new Vehicle();\n则引用变量veh2改指向第二个对象。从以上叙述再推演下去，我们可以获得以下结\n\n一个对象引用可以指向0个或1个对象（一根绳子可以不系汽球，也可以系一个汽球）\n一个对象可以有N个引用指向它（可以有N条绳子系住一个汽球)\n\n按上面的推断，veh1也指向了第二个对象。这个没问题。问题是第一个对象呢？没有一条绳子系住它，它飞了。多数书里说，它被Java的垃圾回收机制回收了。这不确切。正确地说，它已成为垃圾回收机制的处理对象。至于什么时候真正被回收，那要看垃圾回收机制的心情了。由此看来，下面的语句应该不合法吧？至少是没用的吧？\n1new Vehicle();\n不对。它是合法的，而且可用的。譬如，如果我们仅仅为了打印而生成一个对象，就不需要用引用变量来系住它。最常见的就是打印字符串:\n1System.out.println(&quot;I am Java!&quot;);\n字符串对象“I am Java!”在打印后即被丢弃。有人把这种对象称之为临时对象。 对象与引用的关系将持续到对象回收。Java对象及引用是容易混淆却又必须掌握的基础知识，本章阐述Java对象和引用的概念，以及与其密切相关的参数传递。先看下面的程序：\n12StringBuffer s;s = new StringBuffer(&quot;Hello World!&quot;);\n第一个语句仅为引用(reference)分配了空间，而第二个语句则通过调用类(StringBuffer)的构造函数StringBuffer(String str)为类生成了一个实例（或称为对象）。这两个操作被完成后，对象的内容则可通过s进行访问——在Java里都是通过引用来操纵对象的。\nJava对象和引用的关系可以说是互相关联，却又彼此独立。彼此独立主要表现在：引用是可以改变的，它可以指向别的对象，譬如上面的s，你可以给它另外的对象，如：\n1s = new StringBuffer(&quot;Java&quot;);\n这样一来，s就和它指向的第一个对象脱离关系。从存储空间上来说，对象和引用也是独立的，它们存储在不同的地方，对象一般存储在堆中，而引用存储在速度更快的堆栈中。引用可以指向不同的对象，对象也可以被多个引用操纵，如：\n1StringBuffer s1 = s;\n这条语句使得s1和s指向同一个对象。既然两个引用指向同一个对象，那么不管使用哪个引用操纵对象，对象的内容都发生改变，并且只有一份，通过s1和s得到的内容自然也一样，(String除外，因为String始终不变，String s1=”AAAA”; String s=s1,操作s,s1由于始终不变，所以为s另外开辟了空间来存储s,)如下面的程序：\n123456StringBuffer s;  s = new StringBuffer(&quot;Java&quot;);  StringBuffer s1 = s;  s1.append(&quot; World&quot;);  System.out.println(&quot;s1=&quot; + s1.toString());//打印结果为：s1=Java World  System.out.println(&quot;s=&quot; + s.toString());//打印结果为：s=Java World\n上面的程序表明，s1和s打印出来的内容是一样的，这样的结果看起来让人非常疑惑，但是仔细想想s1和s只是两个引用，它们只是操纵杆而已，它们指向同一个对象，操纵的也是同一个对象通过它们得到的是同一个对象的内容。\n这就像汽车的刹车和油门，它们操纵的都是车速假如汽车开始的速度是80，然后你踩了一次油门，汽车加速了，假如车速升到了120，然后你踩一下刹车此时车速是从120开始下降的，假如下降到60，再踩一次油门，车速则从60开始上升而不是从第一次踩油门后的120开始。也就是说车速同时受油门和刹车影响，它们的影响是累积起来的，而不是各自独立（除非刹车和油门不在一辆车上）。所以，在上面的程序中，不管使用s1还是s操纵对象，它们对对象的影响也是累积起来的（更多的引用同理）。只有理解了对象和引用的关系，才能理解参数传递。\n一般面试题中都会考Java传参的问题，并且它的标准答案是Java只有一种参数传递方式：那就是按值传递，即Java中传递任何东西都是传值。如果传入方法的是基本类型的东西，你就得到此基本类型的一份拷贝。如果是传递引用，就得到引用的拷贝。 一般来说，对于基本类型的传递，我们很容易理解，而对于对象，总让人感觉是按引用传递，看下面的程序：\n123456789101112131415161718192021222324252627public class ObjectRef &#123;    //基本类型的参数传递      public static void testBasicType(int m) &#123;          System.out.println(&quot;m=&quot; + m);//m=50          m = 100;          System.out.println(&quot;m=&quot; + m);//m=100      &#125;    //参数为对象，不改变引用的值 ？    public static void add(StringBuffer s) &#123;          s.append(&quot;_add&quot;);      &#125;    //参数为对象，改变引用的值 ？？？？？      public static void changeRef(StringBuffer s) &#123;\t\ts = new StringBuffer(&quot;Java&quot;);      &#125;    public static void main(String[] args) &#123;          int i = 50;          testBasicType(i);          System.out.println(i);//i=50          StringBuffer sMain = new StringBuffer(&quot;init&quot;);          System.out.println(&quot;sMain=&quot; + sMain.toString());//sMain=init          add(sMain);          System.out.println(&quot;sMain=&quot; + sMain.toString());//sMain=init_add          changeRef(sMain);          System.out.println(&quot;sMain=&quot; + sMain.toString());//sMain=init_add      &#125;&#125;\n以上程序的允许结果显示出，testBasicType方法的参数是基本类型，尽管参数m的值发生改变，但并不影响i。add方法的参数是一个对象，当把sMain传给参数s时，s得到的是sMain的拷贝，所以s和sMain指向同一个对象，因此，使用s操作影响的其实就是sMain指向的对象，故调用add方法后，sMain指向的对象的内容发生了改变。\n在changeRef方法中，参数也是对象，当把sMain传给参数s时，s得到的是sMain的拷贝，但与add方法不同的是，在方法体内改变了s指向的对象（也就是s指向了别的对象,牵着气球的绳子换气球了），给s重新赋值后，s与sMain已经毫无关联，它和sMain指向了不同的对象，所以不管对s做什么操作，都不会影响sMain指向的对象，故调用changeRef方法前后sMain指向的对象内容并未发生改变。\n对于add方法的调用结果，可能很多人会有这种感觉：这不明明是按引用传递吗？对于这种问题，还是套用Bruce Eckel的话：这依赖于你如何看待引用，最终你会明白，这个争论并没那么重要。真正重要的是，你要理解，传引用使得（调用者的）对象的修改变得不可预期。\n123456789101112131415161718192021222324public class Test&#123;\tpublic int i,j;    public void test_m(Test a) &#123;\t\tTest b = new Test();\t\tb.i = 1;\t\tb.j = 2;\t\ta = b;    &#125;    public void test_m1(Test a)&#123;\t\ta.i = 1;          a.j = 2;      &#125;    public static void main(String argv[])&#123;\t\tTest t= new Test();  \t\tt.i = 5;  \t\tt.j = 6;  \t\tSystem.out.println(&quot;t.i = &quot;+ t.i + &quot; t.j= &quot; + t.j);  //5,6  \t\tt.test_m(t);  \t\tSystem.out.println(&quot;t.i = &quot;+ t.i + &quot; t.j= &quot; + t.j); //5,6\t\t//a和t都指向了一个对象，而在test_m中s又指向了另一个对象，所以对象t不变！！\t\tt.test_m1(t);\t\tSystem.out.println(&quot;t.i = &quot;+ t.i + &quot; t.j= &quot; + t.j); //1,2      &#125;&#125;\n答案只有一个：Java里都是按值传递参数。而实际上，我们要明白，当参数是对象时，传引用会发生什么状况（就像上面的add方法）？这样来记这个问题如下表达式:\n1A a1 = new A();\n它代表A是类，a1是引用，a1不是对象，new A()才是对象，a1引用指向new A()这个对象。在JAVA里，“=”不能被看成是一个赋值语句，它不是在把一个对象赋给另外一个对象，它的执行过程实质上是将右边对象的地址传给了左边的引用，使得左边的引用指向了右边的对象。JAVA表面上看起来没有指针，但它的引用其实质就是一个指针，引用里面存放的并不是对象，而是该对象的地址，使得该引用指向了对象。在JAVA里，“=”语句不应该被翻译成赋值语句，因为它所执行的确实不是一个赋值的过程，而是一个传地址的过程，被译成赋值语句会造成很多误解，译得不准确。再如:\n1A a2;\n它代表A是类，a2是引用，a2不是对象，a2所指向的对象为空null,再如:\n1a2 = a1;\n它代表，a2是引用，a1也是引用，a1所指向的对象的地址传给了a2(传址）,使得a2和a1指向了同一对象。综上所述，可以简单的记为，在初始化时，“=”语句左边的是引用，右边new出来的是对象。在后面的左右都是引用的“=”语句时，左右的引用同时指向了右边引用所指向的对象。再所谓实例，其实就是对象的同义词。原文作者：zwmf\n","dateCreated":"2017-11-29T09:57:01+08:00","dateModified":"2018-06-03T11:38:46+08:00","datePublished":"2017-11-29T09:57:01+08:00","description":"References and ReferentsA reference object is a layer of indirection between your program code and some other object, called a referent. Each reference object is constructed around its referent, and the referent cannot be changed.\n—Keith D Gregory","headline":"Java Reference Object","image":["https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=960265520,2932106354&fm=27&gp=0.jpg","http://old.bz55.com/uploads/allimg/150719/139-150GZZ039.jpg"],"mainEntityOfPage":{"@type":"WebPage","@id":"https://radiancel.github.io/2017/11/29/Java-Reference-Object/"},"publisher":{"@type":"Organization","name":"Eddie Lee","sameAs":["https://github.com/RadianceL"],"image":"eddie-personal.jpg","logo":{"@type":"ImageObject","url":"eddie-personal.jpg"}},"url":"https://radiancel.github.io/2017/11/29/Java-Reference-Object/","keywords":"Java","thumbnailUrl":"https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=960265520,2932106354&fm=27&gp=0.jpg"}</script>
    <meta name="description" content="References and ReferentsA reference object is a layer of indirection between your program code and some other object, called a referent. Each reference object is constructed around its referent, and t">
<meta name="keywords" content="Java">
<meta property="og:type" content="blog">
<meta property="og:title" content="Java Reference Object">
<meta property="og:url" content="https://radiancel.github.io/2017/11/29/Java-Reference-Object/index.html">
<meta property="og:site_name" content="Blog Bom!!BO!">
<meta property="og:description" content="References and ReferentsA reference object is a layer of indirection between your program code and some other object, called a referent. Each reference object is constructed around its referent, and t">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2018-06-03T03:38:46.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java Reference Object">
<meta name="twitter:description" content="References and ReferentsA reference object is a layer of indirection between your program code and some other object, called a referent. Each reference object is constructed around its referent, and t">
    
    
        
    
    
        <meta property="og:image" content="https://radiancel.github.io/assets/images/eddie-personal.jpg"/>
    
    
        <meta property="og:image" content="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=960265520,2932106354&amp;fm=27&amp;gp=0.jpg"/>
        <meta class="swiftype" name="image" data-type="enum" content="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=960265520,2932106354&amp;fm=27&amp;gp=0.jpg" />
    
    
        <meta property="og:image" content="http://old.bz55.com/uploads/allimg/150719/139-150GZZ039.jpg"/>
        <meta class="swiftype" name="image" data-type="enum" content="http://old.bz55.com/uploads/allimg/150719/139-150GZZ039.jpg" />
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-c4ozcsklz4kht2pebhp44xorvyverh23toayhn7i6ubrpyedak24hv1v0hyd.min.css">
    <!--STYLES END-->
    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">Blog Bom!!BO!</a>
    </div>
    
        
            <a class="header-right-picture " href="#about">
        
        
            <img class="header-picture" src="/assets/images/eddie-personal.jpg" alt="Author&#39;s picture">
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about">
                    <img class="sidebar-profile-picture" src="/assets/images/eddie-personal.jpg" alt="Author&#39;s picture">
                </a>
                <h4 class="sidebar-profile-name">Eddie Lee</h4>
                
                    <h5 class="sidebar-profile-bio"><p>author.bio</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/ " title="Home">
                    
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-categories" title="Categories">
                    
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-tags" title="Tags">
                    
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-archives" title="Archives">
                    
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Archives</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="#about" title="About">
                    
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="https://github.com/RadianceL" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
        <div class="post-header-cover
                    text-left
                    " style="background-image:url('http://old.bz55.com/uploads/allimg/150719/139-150GZZ039.jpg');" data-behavior="4">
            
                <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            Java Reference Object
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2017-11-29T09:57:01+08:00">
	
		    Nov 29, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

    
</div>

            
        </div>

            <div id="main" data-behavior="4"
                 class="hasCover
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <p>References and Referents<br>A reference object is a layer of indirection between your program code and some other object, called a referent. Each reference object is constructed around its referent, and the referent cannot be changed.</p>
<p><div align="right">—Keith D Gregory</div><br><a id="more"></a></p>
<p>初学Java时，在很长一段时间里，总觉得基本概念很模糊。后来才知道，在许多Java书中，把对象和对象的引用混为一谈。<br>可是，如果我分不清对象与对象引用，<br>那实在没法很好地理解下面的面向对象技术。把自己的一点认识写下来，或许能让初学Java的朋友们少走一点弯路。<br>为便于说明，我们先定义一个简单的类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Vehicle &#123;</span><br><span class="line">	int passengers;      </span><br><span class="line">	int fuelcap;</span><br><span class="line">	int mpg;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>有了这个模板，就可以用它来创建对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vehicle veh1 = new Vehicle();</span><br></pre></td></tr></table></figure></p>
<p>通常把这条语句的动作称之为创建一个对象，其实，它包含了四个动作.</p>
<ul>
<li>右边的<code>new Vehicle</code>，是以<code>Vehicle</code>类为模板，在堆空间里创建一个<code>Vehicle</code>类对象（也简称为Vehicle对象）。</li>
<li>末尾的()意味着，在对象创建后，立即调用<code>Vehicle</code>类的构造函数，对刚生成的对象进行初始化。构造函数是肯定有的。如果你没写，Java会给你补上一个默认的构造函数。</li>
<li>左边的<code>Vehicle veh 1</code>创建了一个<code>Vehicle</code>类引用变量。所谓<code>Vehicle</code>类引用，就是以后可以用来指向<code>Vehicle</code>对象的对象引用。</li>
<li>“=”操作符使对象引用指向刚创建的那个<code>Vehicle</code>对象。</li>
</ul>
<p>我们可以把这条语句拆成两部分:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vehicle veh1;</span><br><span class="line">veh1 = new Vehicle();</span><br></pre></td></tr></table></figure>
<p>效果是一样的。这样写，就比较清楚了，有两个实体：一是对象引用变量，一是对象本身。在堆空间里创建的实体，与在数据段以及栈空间里创建的实体不同。尽管它们也是确确实实存在的实体，但是，我们看不见，也摸不着。不仅如此，我们仔细研究一下第二句，找找刚创建的对象叫什么名字？有人说，它叫<code>Vehicle</code>。不对，<code>Vehicle</code>是类（对象的创建模板）的名字。</p>
<p>一个<code>Vehicle</code>类可以据此创建出无数个对象，这些对象不可能全叫<code>Vehicle</code>。对象连名都没有，没法直接访问它。我们只能通过对象引用来间接访问对象。为了形象地说明对象、引用及它们之间的关系，可以做一个或许不很妥当的比喻。对象好比是一只很大的气球，大到我们抓不住它。引用变量是一根绳， 可以用来系汽球。如果只执行了第一条语句，还没执行第二条，此时创建的引用变量<code>veh1</code>还没指向任何一个对象，它的值是<code>null</code>。引用变量可以指向某个对象，或者为<code>null</code></p>
<p>它是一根绳，一根还没有系上任何一个汽球的绳。执行了第二句后，一只新汽球做出来了，并被系在<code>veh1</code>这根绳上。我们抓住这根绳，就等于抓住了那只汽球。再来一句:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vehicle veh2;</span><br></pre></td></tr></table></figure>
<p>就又做了一根绳，还没系上汽球。如果再加一句:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">veh2 = veh1;</span><br></pre></td></tr></table></figure>
<p>系上了。这里，发生了复制行为。但是，要说明的是，对象本身并没有被复制，被复制的只是对象引用。结果是，veh2也指向了veh1所指向的对象。两根绳系的是同一只汽球。<br>如果用下句再创建一个对象:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">veh2 = new Vehicle();</span><br></pre></td></tr></table></figure>
<p>则引用变量<code>veh2</code>改指向第二个对象。<br>从以上叙述再推演下去，我们可以获得以下结</p>
<ul>
<li>一个对象引用可以指向0个或1个对象（一根绳子可以不系汽球，也可以系一个汽球）</li>
<li>一个对象可以有N个引用指向它（可以有N条绳子系住一个汽球)</li>
</ul>
<p>按上面的推断，<code>veh1</code>也指向了第二个对象。这个没问题。问题是第一个对象呢？没有一条绳子系住它，它飞了。多数书里说，它被Java的垃圾回收机制回收了。这不确切。正确地说，它已成为垃圾回收机制的处理对象。至于什么时候真正被回收，那要看垃圾回收机制的心情了。由此看来，下面的语句应该不合法吧？至少是没用的吧？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Vehicle();</span><br></pre></td></tr></table></figure>
<p>不对。它是合法的，而且可用的。譬如，如果我们仅仅为了打印而生成一个对象，就不需要用引用变量来系住它。<br>最常见的就是打印字符串:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;I am Java!&quot;);</span><br></pre></td></tr></table></figure>
<p>字符串对象“I am Java!”在打印后即被丢弃。有人把这种对象称之为临时对象。 对象与引用的关系将持续到对象回收。<br>Java对象及引用是容易混淆却又必须掌握的基础知识，本章阐述Java对象和引用的概念，以及与其密切相关的参数传递。<br>先看下面的程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer s;</span><br><span class="line">s = new StringBuffer(&quot;Hello World!&quot;);</span><br></pre></td></tr></table></figure>
<p>第一个语句仅为引用(reference)分配了空间，而第二个语句则通过调用类(StringBuffer)的构造函数StringBuffer(String str)为类生成了一个实例（或称为对象）。这两个操作被完成后，对象的内容则可通过s进行访问——在Java里都是通过引用来操纵对象的。</p>
<p>Java对象和引用的关系可以说是互相关联，却又彼此独立。彼此独立主要表现在：引用是可以改变的，它可以指向别的对象，譬如上面的s，你可以给它另外的对象，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = new StringBuffer(&quot;Java&quot;);</span><br></pre></td></tr></table></figure>
<p>这样一来，s就和它指向的第一个对象脱离关系。从存储空间上来说，对象和引用也是独立的，它们存储在不同的地方，对象一般存储在堆中，而引用存储在速度更快的堆栈中。引用可以指向不同的对象，对象也可以被多个引用操纵，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer s1 = s;</span><br></pre></td></tr></table></figure>
<p>这条语句使得s1和s指向同一个对象。既然两个引用指向同一个对象，那么不管使用哪个引用操纵对象，对象的内容都发生改变，并且只有一份，通过s1和s得到的内容自然也一样，(String除外，因为String始终不变，String s1=”AAAA”; String s=s1,操作s,s1由于始终不变，所以为s另外开辟了空间来存储s,)如下面的程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer s;  </span><br><span class="line">s = new StringBuffer(&quot;Java&quot;);  </span><br><span class="line">StringBuffer s1 = s;  </span><br><span class="line">s1.append(&quot; World&quot;);  </span><br><span class="line">System.out.println(&quot;s1=&quot; + s1.toString());//打印结果为：s1=Java World  </span><br><span class="line">System.out.println(&quot;s=&quot; + s.toString());//打印结果为：s=Java World</span><br></pre></td></tr></table></figure>
<p>上面的程序表明，s1和s打印出来的内容是一样的，这样的结果看起来让人非常疑惑，但是仔细想想s1和s只是两个引用，它们只是操纵杆而已，它们指向同一个对象，操纵的也是同一个对象通过它们得到的是同一个对象的内容。</p>
<p>这就像汽车的刹车和油门，它们操纵的都是车速假如汽车开始的速度是80，然后你踩了一次油门，汽车加速了，假如车速升到了120，然后你踩一下刹车此时车速是从120开始下降的，假如下降到60，再踩一次油门，车速则从60开始上升而不是从第一次踩油门后的120开始。也就是说车速同时受油门和刹车影响，它们的影响是累积起来的，而不是各自独立（除非刹车和油门不在一辆车上）。所以，在上面的程序中，不管使用s1还是s操纵对象，它们对对象的影响也是累积起来的（更多的引用同理）。只有理解了对象和引用的关系，才能理解参数传递。</p>
<p>一般面试题中都会考Java传参的问题，并且它的标准答案是Java只有一种参数传递方式：那就是按值传递，即Java中传递任何东西都是传值。如果传入方法的是基本类型的东西，你就得到此基本类型的一份拷贝。如果是传递引用，就得到引用的拷贝。 一般来说，对于基本类型的传递，我们很容易理解，而对于对象，总让人感觉是按引用传递，看下面的程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class ObjectRef &#123;</span><br><span class="line">    //基本类型的参数传递  </span><br><span class="line">    public static void testBasicType(int m) &#123;  </span><br><span class="line">        System.out.println(&quot;m=&quot; + m);//m=50  </span><br><span class="line">        m = 100;  </span><br><span class="line">        System.out.println(&quot;m=&quot; + m);//m=100  </span><br><span class="line">    &#125;</span><br><span class="line">    //参数为对象，不改变引用的值 ？</span><br><span class="line">    public static void add(StringBuffer s) &#123;  </span><br><span class="line">        s.append(&quot;_add&quot;);  </span><br><span class="line">    &#125;</span><br><span class="line">    //参数为对象，改变引用的值 ？？？？？  </span><br><span class="line">    public static void changeRef(StringBuffer s) &#123;</span><br><span class="line">		s = new StringBuffer(&quot;Java&quot;);  </span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        int i = 50;  </span><br><span class="line">        testBasicType(i);  </span><br><span class="line">        System.out.println(i);//i=50  </span><br><span class="line">        StringBuffer sMain = new StringBuffer(&quot;init&quot;);  </span><br><span class="line">        System.out.println(&quot;sMain=&quot; + sMain.toString());//sMain=init  </span><br><span class="line">        add(sMain);  </span><br><span class="line">        System.out.println(&quot;sMain=&quot; + sMain.toString());//sMain=init_add  </span><br><span class="line">        changeRef(sMain);  </span><br><span class="line">        System.out.println(&quot;sMain=&quot; + sMain.toString());//sMain=init_add  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上程序的允许结果显示出，testBasicType方法的参数是基本类型，尽管参数m的值发生改变，但并不影响i。add方法的参数是一个对象，当把sMain传给参数s时，s得到的是sMain的拷贝，所以s和sMain指向同一个对象，因此，使用s操作影响的其实就是sMain指向的对象，故调用add方法后，sMain指向的对象的内容发生了改变。</p>
<p>在changeRef方法中，参数也是对象，当把sMain传给参数s时，s得到的是sMain的拷贝，但与add方法不同的是，在方法体内改变了s指向的对象（也就是s指向了别的对象,牵着气球的绳子换气球了），给s重新赋值后，s与sMain已经毫无关联，它和sMain指向了不同的对象，所以不管对s做什么操作，都不会影响sMain指向的对象，故调用changeRef方法前后sMain指向的对象内容并未发生改变。</p>
<p>对于add方法的调用结果，可能很多人会有这种感觉：这不明明是按引用传递吗？对于这种问题，还是套用Bruce Eckel的话：这依赖于你如何看待引用，最终你会明白，这个争论并没那么重要。真正重要的是，你要理解，传引用使得（调用者的）对象的修改变得不可预期。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">	public int i,j;</span><br><span class="line">    public void test_m(Test a) &#123;</span><br><span class="line">		Test b = new Test();</span><br><span class="line">		b.i = 1;</span><br><span class="line">		b.j = 2;</span><br><span class="line">		a = b;</span><br><span class="line">    &#125;</span><br><span class="line">    public void test_m1(Test a)&#123;</span><br><span class="line">		a.i = 1;  </span><br><span class="line">        a.j = 2;  </span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String argv[])&#123;</span><br><span class="line">		Test t= new Test();  </span><br><span class="line">		t.i = 5;  </span><br><span class="line">		t.j = 6;  </span><br><span class="line">		System.out.println(&quot;t.i = &quot;+ t.i + &quot; t.j= &quot; + t.j);  //5,6  </span><br><span class="line">		t.test_m(t);  </span><br><span class="line">		System.out.println(&quot;t.i = &quot;+ t.i + &quot; t.j= &quot; + t.j); //5,6</span><br><span class="line">		//a和t都指向了一个对象，而在test_m中s又指向了另一个对象，所以对象t不变！！</span><br><span class="line">		t.test_m1(t);</span><br><span class="line">		System.out.println(&quot;t.i = &quot;+ t.i + &quot; t.j= &quot; + t.j); //1,2  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答案只有一个：Java里都是按值传递参数。而实际上，我们要明白，当参数是对象时，传引用会发生什么状况（就像上面的add方法）？这样来记这个问题如下表达式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A a1 = new A();</span><br></pre></td></tr></table></figure>
<p>它代表A是类，a1是引用，a1不是对象，new A()才是对象，a1引用指向new A()这个对象。在JAVA里，“=”不能被看成是一个赋值语句，它不是在把一个对象赋给另外一个对象，它的执行过程实质上是将右边对象的地址传给了左边的引用，使得左边的引用指向了右边的对象。JAVA表面上看起来没有指针，但它的引用其实质就是一个指针，引用里面存放的并不是对象，而是该对象的地址，使得该引用指向了对象。在JAVA里，“=”语句不应该被翻译成赋值语句，因为它所执行的确实不是一个赋值的过程，而是一个传地址的过程，被译成赋值语句会造成很多误解，译得不准确。再如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A a2;</span><br></pre></td></tr></table></figure>
<p>它代表A是类，a2是引用，a2不是对象，a2所指向的对象为空null,再如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a2 = a1;</span><br></pre></td></tr></table></figure>
<p>它代表，a2是引用，a1也是引用，a1所指向的对象的地址传给了a2(传址）,使得a2和a1指向了同一对象。综上所述，可以简单的记为，在初始化时，“=”语句左边的是引用，右边new出来的是对象。在后面的左右都是引用的“=”语句时，左右的引用同时指向了右边引用所指向的对象。再所谓实例，其实就是对象的同义词。<br><a href="http://zwmf.iteye.com/blog/1738574" target="_blank" rel="noopener">原文作者：zwmf</a></p>

            

        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">TAGGED IN</span><br>
                
    <a class="tag tag--primary tag--small t-link" href="/tags/Java/">Java</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2017/12/28/C-static-Library/" data-tooltip="C-static-Library" aria-label="PREVIOUS: C-static-Library">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2017/11/29/Android-ViewPagerFramgent/" data-tooltip="Android-ViewPagerFramgent" aria-label="NEXT: Android-ViewPagerFramgent">
                
                    <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Share this post">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Back to top">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2019 Eddie Lee. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2017/12/28/C-static-Library/" data-tooltip="C-static-Library" aria-label="PREVIOUS: C-static-Library">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2017/11/29/Android-ViewPagerFramgent/" data-tooltip="Android-ViewPagerFramgent" aria-label="NEXT: Android-ViewPagerFramgent">
                
                    <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Share this post">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Back to top">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                

            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/eddie-personal.jpg" alt="Author&#39;s picture">
        
            <h4 id="about-card-name">Eddie Lee</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br>
                <p>author.job</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br>
                LN
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-dbd16rvloemmuxdzniplmnxxvwoz24eya9wol0b7vvmlokgqsjivmb8dnscy.min.js"></script>
<!--SCRIPTS END-->

    



    </body>
</html>
