
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Blog Bom!!BO!">
    <title>Spring Boot Operational Principle - Blog Bom!!BO!</title>
    <meta name="author" content="Eddie Lee">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Eddie Lee","sameAs":["https://github.com/RadianceL"],"image":"alan-walker.jpg"},"articleBody":"好久没写博客了，这两天跟教授聊天，提到开始用spring boot，教授问我一系列问题，很多都没有回答上来，此篇博文总结下这两天关于Spring boot工作原理的学习\nSpringSpring 可以说构成了Java之所以这么流行的核心原因，那Spring的核心，两个最为核心的就是IOC（控制反转）与AOP（动态代理）。\nIOC那么什么是IOC，原本我们在一个类（A）依赖另一个类（B）的时候，需要在使用类（A类）的类new出来（B类），那么这个操作，耦合度非常高，如果哪天我们不用那个类（B），改用类（C），那么所有原本依赖（B）的类都要改。\n那IOC是怎么实现的控制反转呢。一种是DI（dependency injection,依赖注入），另一种是DL（dependency lookup，依赖查找）\n第一种是主动注入，另一种是当需要的时候去查找依赖。通常context.getBean(...)这种方式就是DL，去找依赖，而@Autowired是依赖注入（DI）\nAOPAOP面向切面编程其实说白了，就是封装了多个类的公共行为到一个可重用模块AOP是通过Java的动态代理机制来实现的，通过配置和注解的方式，让Spring找到需要被代理的类，然后动态代理这个类，实现在方法，类等执行之前，和之后做的增强操作，一般用于权限，缓存，调试，记录跟踪，错误处理等。\nSpring Annotation@Configuration任何一个标注了@Configuration的Java类定义都是一个JavaConfig配置类。包括SpringBoot的@SpringBootApplicaton,里面也是包含了一个@Configuration,所以Spring Boot的启动类，也是一个JavaConfig。\n@Bean任何一个标注了@Bean的方法，其返回值将作为一个bean定义注册到Spring的IOC容器，方法名将默认成为该Bean定义的id。\n@ComponentScan用于配合一些元信息Java annotation，比如@Component和@Repository等，将标注了这些元信息annotation的bean定义类批量采集到spring的IOC容器中。可以通过basePackages等属性来细粒度地定制@ComponentScan自动扫描的范围，如果不指定，则默认spring框架实现会从声明@ComponentScan所在类的package进行扫描。\n@PropertySource与@PropertySources\n@PropertySource用于从某些地方加载*.properties文件内容，并将其中的属性加载到IOC容器中，便于填充一些bean定义属性的占位符。\n@Import与@ImportResource\n@Import负责引入JavaConfig形式定义的IOC容器配置，如果有一些遗留的配置或者遗留系统需要以xml的形式来配置（比如dubbo框架），我们依然可以通过@ImportResource将它们一起合并到当前JavaConfig配置的容器中。\nSpring IOC启动Spring IOC容器的依赖注入工作可以分为两个阶段：\n\n收集和注册\n第一个阶段可以认为是构建和收集bean定义的阶段，在这个阶段，我们可以通过xml或者Java代码的方式定义一些bean，然后通过手动组装或者让容器基于某些机制自动扫描的方式，将这些bean定义收集到ioc容器中。\nIOC 底层其实是一个Map，把所有的Bean加载到这个Map当中，根据相关机制获取，如果找不到，就会抛出异常，如果配置或bean加载出错，也会在容器启动时报错\n\n\n分析和组装\n当第一个阶段完成后，底层Map容器中有一个个Bean，暂时它们之间是没有什么关系的，第二阶段要做的，就是分析Bean里面的关系，把它们组合起来，达到可用的状态\n\n\n\n默认情况下（无单独配置），Spring加载的Bean对象都是单例模式，每次被注入或者被查找，都是同一个对象（hashCode相同）\nSpring BootSpringBoot并不是对Spring Web框架进行颠覆，而是不同的bean互相作用，如果我们把Spring想象成人体，把Bean当做细胞的话，那么正是不同种类bean的相互协作才使得spring这个大工厂正常运行，有些bean做管理工作，有些bean为其它bean服务，有些bean生产其它bean，通过协作完成功能，而SpringBoot则是有默认约定，帮助完成了大部分Bean的配置，大量简化了需要开发人员编写的配置项。Spring Boot并不是对原有Spring框架的颠覆，而是基于原有功能的一次进化。\n一个典型的Spring Boot项目，就是有一个由@SpringBootApplication注释的main函数进入到@SpringBootApplication，会发现里面有12345678910@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration //核心@EnableAutoConfiguration //核心@ComponentScan(excludeFilters = &#123;@Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class)&#125;) //核心public @interface SpringBootApplication &#123;    ...&#125;\n@EnableAutoConfiguration作为一个复合annotation，其中最关键的要属@Import(AutoConfigurationImportSelector.class)，借助AutoConfigurationImportSelector，@EnableAutoConfiguration可以帮助springboot应用将所有符合条件的@Configuration配置都加载到当前Spring Boot创建并使用的IOC容器，就跟一只八爪鱼一样。AutoConfigurationImportSelector借助spring框架原有的一个工具类SpringFactoriesLoader的支持，@EnableAutoConfiguration可以智能地完成自动配置。\n配合@EnableAutoConfiguration使用的话，它更多是提供一种配置查找的功能支持，即根据@EnableAutoConfiguration的完整类名org.springframework.boot.autoconfigure.EnableAutoConfiguration作为查找的Key，获取对应的一组@Configuration类。所以，@EnableAutoConfiguration自动配置就变成了: 从classpath中搜寻所有的META-INF/spring.factories配置文件，并将其中org.springframework.boot.autoconfigure.EnableutoConfiguration对应的配置项通过反射（Java Refletion）实例化为对应的标注了@Configuration的JavaConfig形式的IoC容器配置类，然后汇总为一个并加载到IoC容器。\nSpringFactoriesLoader主要功能是从指定的配置文件META-INF/spring.factories加载配置，spring.factories是一个典型的Java properties文件，配置的格式为key=value形式，只不过key和value都是Java类型的完整类型。\n那么，既然Spring Boot的启动项也被@SpringBootConfiguration注释了，那么说明这也是一个配置类。Spring Boot最强的地方，在于约定大于配置，所谓开箱即用，那么，约定是怎么做的呢？\nSpring Boot AutoConfig类里面，默认编写了很多配置类，实现约定的核心就是，Boot导入这些配置，变成Bean对象那么Spring Boot的启动顺序就应该是：\n\n如果我们使用的是SpringApplication的静态run方法，那么，这个方法里面首先要创建一个SpringApplication对象实例，然后调用这个创建好的SpringApplication的实例方法。在SpringApplication实例初始化的时候，它会提前做几件事情：\n根据classpath里面是否存在某个特征类org.springframework.web.context.ConfigurableWebApplicationContext来决定是否应该创建一个为Web应用使用的ApplicationContext类型。\n使用SpringFactoriesLoader在应用的classpath中查找并加载所有可用的ApplicationContextInitializer。\n使用SpringFactoriesLoader在应用的classpath中查找并加载所有可用的ApplicationListener。\n推断并设置main方法的定义类。\n\n\nSpringApplication实例初始化完成并且完成设置后，就开始执行run方法的逻辑了，方法执行伊始，首先遍历执行所有通过SpringFactoriesLoader可以查找到并加载的SpringApplicationRunListener。调用它们的started()方法，告诉这些SpringApplicationRunListener，“嘿，SpringBoot应用要开始执行咯！”。\n创建并配置当前Spring Boot应用将要使用的Environment（包括配置要使用的PropertySource以及Profile）。\n遍历调用所有SpringApplicationRunListener的environmentPrepared()的方法，告诉他们：“当前SpringBoot应用使用的Environment准备好了咯！”。\n如果SpringApplication的showBanner属性被设置为true，则打印banner。\n根据用户是否明确设置了applicationContextClass类型以及初始化阶段的推断结果，决定该为当前SpringBoot应用创建什么类型的ApplicationContext并创建完成，然后根据条件决定是否添加ShutdownHook，决定是否使用自定义的BeanNameGenerator，决定是否使用自定义的ResourceLoader，当然，最重要的，将之前准备好的Environment设置给创建好的ApplicationContext使用。\nApplicationContext创建好之后，SpringApplication会再次借助Spring-FactoriesLoader，查找并加载classpath中所有可用的ApplicationContext-Initializer，然后遍历调用这些ApplicationContextInitializer的initialize（applicationContext）方法来对已经创建好的ApplicationContext进行进一步的处理。\n遍历调用所有SpringApplicationRunListener的contextPrepared()方法。\n最核心的一步，将之前通过@EnableAutoConfiguration获取的所有配置以及其他形式的IoC容器配置加载到已经准备完毕的ApplicationContext。\n遍历调用所有SpringApplicationRunListener的contextLoaded()方法。\n调用ApplicationContext的refresh()方法，完成IoC容器可用的最后一道工序。\n遍历调用所有SpringApplicationRunListener的contextLoaded()方法。\n查找当前ApplicationContext中是否注册有CommandLineRunner，如果有，则遍历执行它们。\n正常情况下，遍历执行SpringApplicationRunListener的finished()方法、（如果整个过程出现异常，则依然调用所有SpringApplicationRunListener的finished()方法，只不过这种情况下会将异常信息一并传入处理）\n\n\n\nSpring Boot总结启动：每个SpringBoot程序都有一个主入口，也就是main方法，main里面调用SpringApplication.run()启动整个spring-boot程序，该方法所在类需要使用@SpringBootApplication注解，以及@ImportResource注解(if need)，@SpringBootApplication包括三个注解，功能如下：\n\n@EnableAutoConfiguration  SpringBoot根据应用所声明的依赖来对Spring框架进行自动配置。\n@SpringBootConfiguration(内部为@Configuration)  被标注的类等于在spring的XML配置文件中(applicationContext.xml)，装配所有bean事务，提供了一个spring的上下文环境。\n@ComponentScan：组件扫描，可自动发现和装配Bean，默认扫描SpringApplication的run方法里的Booter.class所在的包路径下文件，所以最好将该启动类放到根包路径下。\n\nrun方法中去创建了一个SpringApplication实例，在该构造方法内，我们可以发现其调用了一个初始化的initialize方法主要是为SpringApplication对象赋一些初值。构造函数执行完毕后，我们回到run方法\n\n创建了应用的监听器SpringApplicationRunListeners并开始监听\n加载Spring Boot配置环境ConfigurableEnvironment，如果是通过web容器发布，会加载StandardEnvironment，其最终也是继承了ConfigurableEnvironment*Environment最终都实现了PropertyResolver接口，我们平时通过environment对象获取配置文件中指定Key对应的value方法时，就是调用了propertyResolver接口的getProperty方法\n\n配置环境Environment加入到监听器对象中SpringApplicationRunListeners\n\n创建run方法的返回对象：ConfigurableApplicationContext(应用配置上下文)，我们可以看一下创建方法\n\n方法会先获取显式设置的应用上下文applicationContextClass，如果不存在，再加载默认的环境配置（通过是否是web environment判断），默认选择AnnotationConfigApplicationContext注解上下文（通过扫描所有注解类来加载bean），最后通过BeanUtils实例化上下文对象，并返回。\n\n\n\nConfigurableApplicationContext 的继承树中实现了LifeCycle和ApplicationContext：LifeCycle：生命周期类，定义了start启动、stop结束、isRunning是否运行中等生命周期空值方法ApplicationContext：应用上下文类，其主要继承了beanFactory(bean的工厂类)\n\n回到run方法内，prepareContext方法将listeners、environment、applicationArguments、banner等重要组件与上下文对象关联\n\n接下来的refreshContextcontext方法(初始化方法如下)将是实现spring-boot-starter-(mybatis、redis...)自动化配置的关键，包括spring.factories的加载，bean的实例化等核心工作。\n\n\n配置结束后，Spring Boot做了一些基本的收尾工作，返回了应用环境上下文。回顾整体流程，Spring Boot的启动，主要创建了配置环境(environment)、事件监听(listeners)、应用上下文(applicationContext)，并基于以上条件，在容器中开始实例化我们需要的Bean，至此，通过Spring Boot启动的程序已经构造完成，接下来我们来探讨自动化配置是如何实现。\n自动配置之前的启动结构中，我们注意到无论是应用初始化还是具体的执行过程，都调用了Spring Boot自动配置模块。\n该配置模块的主要使用到了SpringFactoriesLoader，即Spring工厂加载器，该对象提供了loadFactoryNames方法，入参为factoryClass和classLoader，即需要传入上图中的工厂类名称和对应的类加载器，方法会根据指定的classLoader，加载该类加器搜索路径下的指定文件，即spring.factories文件，传入的工厂类为接口，而文件中对应的类则是接口的实现类，或最终作为实现类，所以文件中一般为如下图这种一对多的类名集合，获取到这些实现类的类名后，loadFactoryNames方法返回类名集合，方法调用方得到这些集合后，再通过反射获取这些类的类对象、构造方法，最终生成实例。\nmybatis-spring-boot-starter、spring-boot-starter-web等组件的META-INF文件下均含有spring.factories文件，自动配置模块中，SpringFactoriesLoader收集到文件中的类全名并返回一个类全名的数组，返回的类全名通过反射被实例化，就形成了具体的工厂实例，工厂实例来生成组件具体需要的bean。\n之前我们提到了EnableAutoConfiguration注解，关注他的类图可以发现其最终实现了ImportSelector(选择器)和BeanClassLoaderAware(bean类加载器中间件)，重点关注一下AutoConfigurationImportSelector的selectImports方法。\n123456789101112131415161718@Override\tpublic String[] selectImports(AnnotationMetadata annotationMetadata) &#123;\t\tif (!isEnabled(annotationMetadata)) &#123;\t\t\treturn NO_IMPORTS;\t\t&#125;\t\tAutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader\t\t\t\t.loadMetadata(this.beanClassLoader);\t\tAnnotationAttributes attributes = getAttributes(annotationMetadata);\t\tList&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata,\t\t\t\tattributes);\t\tconfigurations = removeDuplicates(configurations);\t\tSet&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);\t\tcheckExcludedClasses(configurations, exclusions);\t\tconfigurations.removeAll(exclusions);\t\tconfigurations = filter(configurations, autoConfigurationMetadata);\t\tfireAutoConfigurationImportEvents(configurations, exclusions);\t\treturn StringUtils.toStringArray(configurations);\t&#125;\n该方法在Spring Boot启动流程——bean实例化前被执行，返回要实例化的类信息列表。我们知道，如果获取到类信息，spring自然可以通过类加载器将类加载到jvm中，现在我们已经通过spring-boot的starter依赖方式依赖了我们需要的组件，那么这些组建的类信息在select方法中也是可以被获取到的，不要急我们继续向下分析。\n该方法中的getCandidateConfigurations方法，通过方法注释了解到，其返回一个自动配置类的类名列表，方法调用了loadFactoryNames方法，查看该方法123456789protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata,\t\t\tAnnotationAttributes attributes) &#123;\t\tList&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(\t\t\t\tgetSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());\t\tAssert.notEmpty(configurations,\t\t\t\t\"No auto configuration classes found in META-INF/spring.factories. If you \"\t\t\t\t\t\t+ \"are using a custom packaging, make sure that file is correct.\");\t\treturn configurations;&#125;\n在上面的代码可以看到自动配置器会根据传入的factoryClass.getName()到项目系统路径下所有的spring.factories文件中找到相应的key，从而加载里面的类。我们就选取这个mybatis-spring-boot-autoconfigure下的spring.factories文件\n123# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration\n进入org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration中，主要看一下类头：\n123456@org.springframework.context.annotation.Configuration@ConditionalOnClass(&#123; SqlSessionFactory.class, SqlSessionFactoryBean.class &#125;)@ConditionalOnBean(DataSource.class)@EnableConfigurationProperties(MybatisProperties.class)@AutoConfigureAfter(DataSourceAutoConfiguration.class)public class MybatisAutoConfiguration\n发现Spring的@Configuration，俨然是一个通过注解标注的springBean，继续向下看，\n@ConditionalOnClass({ SqlSessionFactory.class, SqlSessionFactoryBean.class})这个注解的意思是：当存在SqlSessionFactory.class, SqlSessionFactoryBean.class这两个类时才解析MybatisAutoConfiguration配置类，否则不解析这一个配置类，make sence，我们需要mybatis为我们返回会话对象，就必须有会话工厂相关类。\n@CondtionalOnBean(DataSource.class)：只有处理已经被声明为bean的dataSource。\n@ConditionalOnMissingBean(MapperFactoryBean.class)这个注解的意思是如果容器中不存在name指定的bean则创建bean注入，否则不执行（该类源码较长，篇幅限制不全粘贴）\n以上配置可以保证sqlSessionFactory、sqlSessionTemplate、dataSource等mybatis所需的组件均可被自动配置，@Configuration注解已经提供了Spring的上下文环境，所以以上组件的配置方式与Spring启动时通过mybatis.xml文件进行配置起到一个效果。通过分析我们可以发现，只要一个基于SpringBoot项目的类路径下存在SqlSessionFactory.class, SqlSessionFactoryBean.class，并且容器中已经注册了dataSourceBean，就可以触发自动化配置，意思说我们只要在maven的项目中加入了mybatis所需要的若干依赖，就可以触发自动配置，但引入mybatis原生依赖的话，每集成一个功能都要去修改其自动化配置类，那就得不到开箱即用的效果了。所以Spring-boot为我们提供了统一的starter可以直接配置好相关的类，触发自动配置所需的依赖(mybatis)如下：\n这里是截取的mybatis-spring-boot-starter的源码中pom.xml文件中所有依赖：\n12345678910111213141516171819202122&lt;dependencies&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;&lt;artifactId&gt;mybatis-spring-boot-autoconfigure&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.mybatis&lt;/groupId&gt;&lt;artifactId&gt;mybatis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.mybatis&lt;/groupId&gt;&lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;&lt;/dependency&gt;&lt;/dependencies&gt;\n可以看到其中mybatis-spring-boot-autoconfigure就是配置文件，实现开箱即用123# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration\n","dateCreated":"2018-09-14T12:09:40+08:00","dateModified":"2018-09-18T14:46:02+08:00","datePublished":"2018-09-14T12:09:40+08:00","description":"好久没写博客了，这两天跟教授聊天，提到开始用spring boot，教授问我一系列问题，很多都没有回答上来，此篇博文总结下这两天关于Spring boot工作原理的学习","headline":"Spring Boot Operational Principle","image":["https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=960265520,2932106354&fm=27&gp=0.jpg","http://old.bz55.com/uploads/allimg/150719/139-150GZZ039.jpg"],"mainEntityOfPage":{"@type":"WebPage","@id":"https://radiancel.github.io/2018/09/14/Spring-Boot-Operational-Principle/"},"publisher":{"@type":"Organization","name":"Eddie Lee","sameAs":["https://github.com/RadianceL"],"image":"alan-walker.jpg","logo":{"@type":"ImageObject","url":"alan-walker.jpg"}},"url":"https://radiancel.github.io/2018/09/14/Spring-Boot-Operational-Principle/","keywords":"FrameWork","thumbnailUrl":"https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=960265520,2932106354&fm=27&gp=0.jpg"}</script>
    <meta name="description" content="好久没写博客了，这两天跟教授聊天，提到开始用spring boot，教授问我一系列问题，很多都没有回答上来，此篇博文总结下这两天关于Spring boot工作原理的学习">
<meta name="keywords" content="FrameWork">
<meta property="og:type" content="blog">
<meta property="og:title" content="Spring Boot Operational Principle">
<meta property="og:url" content="https://radiancel.github.io/2018/09/14/Spring-Boot-Operational-Principle/index.html">
<meta property="og:site_name" content="Blog Bom!!BO!">
<meta property="og:description" content="好久没写博客了，这两天跟教授聊天，提到开始用spring boot，教授问我一系列问题，很多都没有回答上来，此篇博文总结下这两天关于Spring boot工作原理的学习">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2018-09-18T06:46:02.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Spring Boot Operational Principle">
<meta name="twitter:description" content="好久没写博客了，这两天跟教授聊天，提到开始用spring boot，教授问我一系列问题，很多都没有回答上来，此篇博文总结下这两天关于Spring boot工作原理的学习">
    
    
        
    
    
        <meta property="og:image" content="https://radiancel.github.io/assets/images/alan-walker.jpg"/>
    
    
        <meta property="og:image" content="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=960265520,2932106354&amp;fm=27&amp;gp=0.jpg"/>
        <meta class="swiftype" name="image" data-type="enum" content="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=960265520,2932106354&amp;fm=27&amp;gp=0.jpg" />
    
    
        <meta property="og:image" content="http://old.bz55.com/uploads/allimg/150719/139-150GZZ039.jpg"/>
        <meta class="swiftype" name="image" data-type="enum" content="http://old.bz55.com/uploads/allimg/150719/139-150GZZ039.jpg" />
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-du2xmrqdqrl2ollgeiw050kpl6l4nbyz7bumjuurjgsxyopifvukebxc9lqe.min.css">
    <!--STYLES END-->
    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">Blog Bom!!BO!</a>
    </div>
    
        
            <a  class="header-right-picture "
                href="#about">
        
        
            <img class="header-picture" src="/assets/images/alan-walker.jpg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about">
                    <img class="sidebar-profile-picture" src="/assets/images/alan-walker.jpg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">Eddie Lee</h4>
                
                    <h5 class="sidebar-profile-bio"><p>Once work as assistant teacher, and now in LN bld Technology Co. Ltd</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/ "
                            
                            title="Home"
                        >
                    
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-categories"
                            
                            title="Categories"
                        >
                    
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-tags"
                            
                            title="Tags"
                        >
                    
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-archives"
                            
                            title="Archives"
                        >
                    
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Archives</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="#about"
                            
                            title="About"
                        >
                    
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://github.com/RadianceL" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
        <div class="post-header-cover
                    text-left
                    "
             style="background-image:url('http://old.bz55.com/uploads/allimg/150719/139-150GZZ039.jpg');"
             data-behavior="4">
            
                <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            Spring Boot Operational Principle
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2018-09-14T12:09:40+08:00">
	
		    Sep 14, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

    
</div>

            
        </div>

            <div id="main" data-behavior="4"
                 class="hasCover
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <p>好久没写博客了，这两天跟教授聊天，提到开始用spring boot，教授问我一系列问题，很多都没有回答上来，此篇博文总结下这两天关于Spring boot工作原理的学习<br><a id="more"></a></p>
<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><p>Spring 可以说构成了Java之所以这么流行的核心原因，那Spring的核心，两个最为核心的就是IOC（控制反转）与AOP（动态代理）。</p>
<h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p>那么什么是IOC，原本我们在一个类（A）依赖另一个类（B）的时候，需要在使用类（A类）的类new出来（B类），那么这个操作，耦合度非常高，如果哪天我们不用那个类（B），改用类（C），那么所有原本依赖（B）的类都要改。</p>
<p>那IOC是怎么实现的控制反转呢。<br>一种是DI（dependency injection,依赖注入），另一种是DL（dependency lookup，依赖查找）</p>
<p>第一种是主动注入，另一种是当需要的时候去查找依赖。<br>通常<code>context.getBean(...)</code>这种方式就是DL，去找依赖，而<code>@Autowired</code>是依赖注入（DI）</p>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>AOP面向切面编程其实说白了，就是封装了多个类的公共行为到一个可重用模块<br>AOP是通过Java的动态代理机制来实现的，通过配置和注解的方式，让Spring找到需要被代理的类，然后动态代理这个类，实现在方法，类等执行之前，和之后做的增强操作，一般用于权限，缓存，调试，记录跟踪，错误处理等。</p>
<h3 id="Spring-Annotation"><a href="#Spring-Annotation" class="headerlink" title="Spring Annotation"></a>Spring Annotation</h3><p><code>@Configuration</code><br>任何一个标注了<code>@Configuration</code>的Java类定义都是一个JavaConfig配置类。包括SpringBoot的<code>@SpringBootApplicaton</code>,里面也是包含了一个<code>@Configuration</code>,所以Spring Boot的启动类，也是一个JavaConfig。</p>
<p><code>@Bean</code><br>任何一个标注了<code>@Bean</code>的方法，其返回值将作为一个bean定义注册到Spring的IOC容器，方法名将默认成为该Bean定义的id。</p>
<p><code>@ComponentScan</code><br>用于配合一些元信息Java annotation，比如<code>@Component</code>和<code>@Repository</code>等，将标注了这些元信息annotation的bean定义类批量采集到spring的IOC容器中。可以通过basePackages等属性来细粒度地定制<code>@ComponentScan</code>自动扫描的范围，如果不指定，则默认spring框架实现会从声明<code>@ComponentScan</code>所在类的package进行扫描。</p>
<p><code>@PropertySource</code>与<code>@PropertySources</code></p>
<p><code>@PropertySource</code>用于从某些地方加载*.properties文件内容，并将其中的属性加载到IOC容器中，便于填充一些bean定义属性的占位符。</p>
<p><code>@Import</code>与<code>@ImportResource</code></p>
<p><code>@Import</code>负责引入JavaConfig形式定义的IOC容器配置，如果有一些遗留的配置或者遗留系统需要以xml的形式来配置（比如dubbo框架），我们依然可以通过<code>@ImportResource</code>将它们一起合并到当前JavaConfig配置的容器中。</p>
<h3 id="Spring-IOC启动"><a href="#Spring-IOC启动" class="headerlink" title="Spring IOC启动"></a>Spring IOC启动</h3><p>Spring IOC容器的依赖注入工作可以分为两个阶段：</p>
<ol>
<li>收集和注册<ul>
<li>第一个阶段可以认为是构建和收集bean定义的阶段，在这个阶段，我们可以通过xml或者Java代码的方式定义一些bean，然后通过手动组装或者让容器基于某些机制自动扫描的方式，将这些bean定义收集到ioc容器中。</li>
<li>IOC 底层其实是一个Map，把所有的Bean加载到这个Map当中，根据相关机制获取，如果找不到，就会抛出异常，如果配置或bean加载出错，也会在容器启动时报错</li>
</ul>
</li>
<li>分析和组装<ul>
<li>当第一个阶段完成后，底层Map容器中有一个个Bean，暂时它们之间是没有什么关系的，第二阶段要做的，就是分析Bean里面的关系，把它们组合起来，达到可用的状态</li>
</ul>
</li>
</ol>
<p>默认情况下（无单独配置），Spring加载的Bean对象都是单例模式，每次被注入或者被查找，都是同一个对象（hashCode相同）</p>
<h1 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h1><p>SpringBoot并不是对Spring Web框架进行颠覆，而是不同的bean互相作用，如果我们把Spring想象成人体，把Bean当做细胞的话，那么正是不同种类bean的相互协作才使得spring这个大工厂正常运行，有些bean做管理工作，有些bean为其它bean服务，有些bean生产其它bean，通过协作完成功能，而SpringBoot则是有默认约定，帮助完成了大部分Bean的配置，大量简化了需要开发人员编写的配置项。Spring Boot并不是对原有Spring框架的颠覆，而是基于原有功能的一次进化。</p>
<p>一个典型的Spring Boot项目，就是有一个由<code>@SpringBootApplication</code>注释的main函数<br>进入到<code>@SpringBootApplication</code>，会发现里面有<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span> <span class="comment">//核心</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span> <span class="comment">//核心</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123;<span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),<span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class)&#125;) <span class="comment">//核心</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>@EnableAutoConfiguration</code>作为一个复合annotation，其中最关键的要属<code>@Import(AutoConfigurationImportSelector.class)</code>，借助AutoConfigurationImportSelector，<code>@EnableAutoConfiguration</code>可以帮助springboot应用将所有符合条件的<code>@Configuration</code>配置都加载到当前Spring Boot创建并使用的IOC容器，就跟一只八爪鱼一样。<br>AutoConfigurationImportSelector借助spring框架原有的一个工具类SpringFactoriesLoader的支持，<code>@EnableAutoConfiguration</code>可以智能地完成自动配置。</p>
<p>配合<code>@EnableAutoConfiguration</code>使用的话，它更多是提供一种配置查找的功能支持，即根据<code>@EnableAutoConfiguration</code>的完整类名<code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code>作为查找的Key，获取对应的一组<code>@Configuration</code>类。<br>所以，<code>@EnableAutoConfiguration</code>自动配置就变成了: 从classpath中搜寻所有的<code>META-INF/spring.factories</code>配置文件，并将其中<code>org.springframework.boot.autoconfigure.EnableutoConfiguration</code>对应的配置项通过反射（Java Refletion）实例化为对应的标注了<code>@Configuration的JavaConfig</code>形式的IoC容器配置类，然后汇总为一个并加载到IoC容器。</p>
<p><code>SpringFactoriesLoader</code>主要功能是从指定的配置文件<code>META-INF/spring.factories</code>加载配置，<code>spring.factories</code>是一个典型的Java properties文件，配置的格式为key=value形式，只不过key和value都是Java类型的完整类型。</p>
<h2 id="那么，既然Spring-Boot的启动项也被-SpringBootConfiguration注释了，那么说明这也是一个配置类。"><a href="#那么，既然Spring-Boot的启动项也被-SpringBootConfiguration注释了，那么说明这也是一个配置类。" class="headerlink" title="那么，既然Spring Boot的启动项也被@SpringBootConfiguration注释了，那么说明这也是一个配置类。"></a>那么，既然Spring Boot的启动项也被<code>@SpringBootConfiguration</code>注释了，那么说明这也是一个配置类。</h2><p>Spring Boot最强的地方，在于约定大于配置，所谓开箱即用，那么，约定是怎么做的呢？</p>
<p>Spring Boot AutoConfig类里面，默认编写了很多配置类，实现约定的核心就是，Boot导入这些配置，变成Bean对象<br>那么Spring Boot的启动顺序就应该是：</p>
<ol>
<li>如果我们使用的是<code>SpringApplication</code>的静态run方法，那么，这个方法里面首先要创建一个<code>SpringApplication</code>对象实例，然后调用这个创建好的<code>SpringApplication</code>的实例方法。在<code>SpringApplication</code>实例初始化的时候，它会提前做几件事情：<ul>
<li>根据classpath里面是否存在某个特征类<code>org.springframework.web.context.ConfigurableWebApplicationContext</code>来决定是否应该创建一个为Web应用使用的<code>ApplicationContext</code>类型。</li>
<li>使用<code>SpringFactoriesLoader</code>在应用的classpath中查找并加载所有可用的<code>ApplicationContextInitializer</code>。</li>
<li>使用<code>SpringFactoriesLoader</code>在应用的classpath中查找并加载所有可用的<code>ApplicationListener</code>。</li>
<li>推断并设置main方法的定义类。</li>
</ul>
</li>
<li><code>SpringApplication</code>实例初始化完成并且完成设置后，就开始执行run方法的逻辑了，方法执行伊始，首先遍历执行所有通过<code>SpringFactoriesLoader</code>可以查找到并加载的<code>SpringApplicationRunListener</code>。调用它们的started()方法，告诉这些<code>SpringApplicationRunListener</code>，“嘿，SpringBoot应用要开始执行咯！”。<ul>
<li>创建并配置当前Spring Boot应用将要使用的<code>Environment</code>（包括配置要使用的PropertySource以及Profile）。</li>
<li>遍历调用所有<code>SpringApplicationRunListener</code>的environmentPrepared()的方法，告诉他们：“当前SpringBoot应用使用的Environment准备好了咯！”。</li>
<li>如果<code>SpringApplication的showBanner</code>属性被设置为true，则打印banner。</li>
<li>根据用户是否明确设置了<code>applicationContextClass</code>类型以及初始化阶段的推断结果，决定该为当前SpringBoot应用创建什么类型的<code>ApplicationContext</code>并创建完成，然后根据条件决定是否添加<code>ShutdownHook</code>，决定是否使用自定义的<code>BeanNameGenerator</code>，决定是否使用自定义的<code>ResourceLoader</code>，当然，最重要的，将之前准备好的<code>Environment</code>设置给创建好的<code>ApplicationContext</code>使用。</li>
<li><code>ApplicationContext</code>创建好之后，<code>SpringApplication</code>会再次借助<code>Spring-FactoriesLoader</code>，查找并加载classpath中所有可用的<code>ApplicationContext-Initializer</code>，然后遍历调用这些<code>ApplicationContextInitializer</code>的initialize（applicationContext）方法来对已经创建好的<code>ApplicationContext</code>进行进一步的处理。</li>
<li>遍历调用所有<code>SpringApplicationRunListener</code>的contextPrepared()方法。</li>
<li>最核心的一步，将之前通过<code>@EnableAutoConfiguration</code>获取的所有配置以及其他形式的IoC容器配置加载到已经准备完毕的<code>ApplicationContext</code>。</li>
<li>遍历调用所有<code>SpringApplicationRunListener</code>的contextLoaded()方法。</li>
<li>调用<code>ApplicationContext</code>的refresh()方法，完成IoC容器可用的最后一道工序。</li>
<li>遍历调用所有<code>SpringApplicationRunListener</code>的contextLoaded()方法。</li>
<li>查找当前<code>ApplicationContext</code>中是否注册有<code>CommandLineRunner</code>，如果有，则遍历执行它们。</li>
<li>正常情况下，遍历执行<code>SpringApplicationRunListener</code>的finished()方法、（如果整个过程出现异常，则依然调用所有<code>SpringApplicationRunListener</code>的finished()方法，只不过这种情况下会将异常信息一并传入处理）</li>
</ul>
</li>
</ol>
<h1 id="Spring-Boot总结"><a href="#Spring-Boot总结" class="headerlink" title="Spring Boot总结"></a>Spring Boot总结</h1><p>启动：<br>每个SpringBoot程序都有一个主入口，也就是main方法，main里面调用SpringApplication.run()启动整个spring-boot程序，该方法所在类需要使用<code>@SpringBootApplication</code>注解，以及<code>@ImportResource</code>注解(if need)，<code>@SpringBootApplication</code>包括三个注解，功能如下：</p>
<ul>
<li><code>@EnableAutoConfiguration</code>  SpringBoot根据应用所声明的依赖来对Spring框架进行自动配置。</li>
<li><code>@SpringBootConfiguration</code>(内部为@Configuration)  被标注的类等于在spring的XML配置文件中(applicationContext.xml)，装配所有bean事务，提供了一个spring的上下文环境。</li>
<li><code>@ComponentScan</code>：组件扫描，可自动发现和装配Bean，默认扫描<code>SpringApplication</code>的run方法里的<code>Booter.class</code>所在的包路径下文件，所以最好将该启动类放到根包路径下。</li>
</ul>
<p>run方法中去创建了一个<code>SpringApplication</code>实例，在该构造方法内，我们可以发现其调用了一个初始化的<code>initialize</code>方法<br>主要是为<code>SpringApplication</code>对象赋一些初值。构造函数执行完毕后，我们回到run方法</p>
<ol>
<li>创建了应用的监听器<code>SpringApplicationRunListeners</code>并开始监听</li>
<li><p>加载Spring Boot配置环境<code>ConfigurableEnvironment</code>，如果是通过web容器发布，会加载<code>StandardEnvironment</code>，其最终也是继承了<code>ConfigurableEnvironment*Environment</code>最终都实现了P<code>ropertyResolver</code>接口，我们平时通过<code>environment</code>对象获取配置文件中指定Key对应的value方法时，就是调用了<code>propertyResolver</code>接口的getProperty方法</p>
</li>
<li><p>配置环境<code>Environment</code>加入到监听器对象中<code>SpringApplicationRunListeners</code></p>
</li>
<li><p>创建run方法的返回对象：<code>ConfigurableApplicationContext</code>(应用配置上下文)，我们可以看一下创建方法</p>
<ul>
<li>方法会先获取显式设置的应用上下文<code>applicationContextClass</code>，如果不存在，再加载默认的环境配置（通过是否是web environment判断），默认选择<code>AnnotationConfigApplicationContext</code>注解上下文（通过扫描所有注解类来加载bean），最后通过<code>BeanUtils</code>实例化上下文对象，并返回。</li>
</ul>
</li>
</ol>
<p><code>ConfigurableApplicationContext</code> 的继承树中实现了LifeCycle和ApplicationContext：<br>LifeCycle：生命周期类，定义了start启动、stop结束、isRunning是否运行中等生命周期空值方法<br>ApplicationContext：应用上下文类，其主要继承了beanFactory(bean的工厂类)</p>
<ol>
<li><p>回到run方法内，<code>prepareContext</code>方法将<code>listeners</code>、<code>environment</code>、<code>applicationArguments</code>、<code>banner</code>等重要组件与上下文对象关联</p>
</li>
<li><p>接下来的refreshContext<code>context</code>方法(初始化方法如下)将是实现<code>spring-boot-starter-(mybatis、redis...)</code>自动化配置的关键，包括<code>spring.factories</code>的加载，bean的实例化等核心工作。</p>
</li>
</ol>
<p>配置结束后，Spring Boot做了一些基本的收尾工作，返回了应用环境上下文。回顾整体流程，Spring Boot的启动，主要创建了配置环境(environment)、事件监听(listeners)、应用上下文(applicationContext)，并基于以上条件，在容器中开始实例化我们需要的Bean，至此，通过Spring Boot启动的程序已经构造完成，接下来我们来探讨自动化配置是如何实现。</p>
<h2 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h2><p>之前的启动结构中，我们注意到无论是应用初始化还是具体的执行过程，都调用了Spring Boot自动配置模块。</p>
<p>该配置模块的主要使用到了<code>SpringFactoriesLoader</code>，即Spring工厂加载器，该对象提供了<code>loadFactoryNames</code>方法，入参为<code>factoryClass</code>和<code>classLoader</code>，即需要传入上图中的工厂类名称和对应的类加载器，方法会根据指定的<code>classLoader</code>，加载该类加器搜索路径下的指定文件，即<code>spring.factories</code>文件，传入的工厂类为接口，而文件中对应的类则是接口的实现类，或最终作为实现类，所以文件中一般为如下图这种一对多的类名集合，获取到这些实现类的类名后，loadFactoryNames方法返回类名集合，方法调用方得到这些集合后，再通过反射获取这些类的类对象、构造方法，最终生成实例。</p>
<p><code>mybatis-spring-boot-starter</code>、<code>spring-boot-starter-web</code>等组件的META-INF文件下均含有<code>spring.factories</code>文件，自动配置模块中，<code>SpringFactoriesLoader</code>收集到文件中的类全名并返回一个类全名的数组，返回的类全名通过反射被实例化，就形成了具体的工厂实例，工厂实例来生成组件具体需要的bean。</p>
<p>之前我们提到了<code>EnableAutoConfiguration</code>注解，关注他的类图<br>可以发现其最终实现了<code>ImportSelector</code>(选择器)和<code>BeanClassLoaderAware</code>(bean类加载器中间件)，重点关注一下<code>AutoConfigurationImportSelector</code>的<code>selectImports</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">			<span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">		&#125;</span><br><span class="line">		AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader</span><br><span class="line">				.loadMetadata(<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">		AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line">		List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata,</span><br><span class="line">				attributes);</span><br><span class="line">		configurations = removeDuplicates(configurations);</span><br><span class="line">		Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">		checkExcludedClasses(configurations, exclusions);</span><br><span class="line">		configurations.removeAll(exclusions);</span><br><span class="line">		configurations = filter(configurations, autoConfigurationMetadata);</span><br><span class="line">		fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">		<span class="keyword">return</span> StringUtils.toStringArray(configurations);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>该方法在Spring Boot启动流程——bean实例化前被执行，返回要实例化的类信息列表。我们知道，如果获取到类信息，spring自然可以通过类加载器将类加载到jvm中，现在我们已经通过spring-boot的starter依赖方式依赖了我们需要的组件，那么这些组建的类信息在select方法中也是可以被获取到的，不要急我们继续向下分析。</p>
<p>该方法中的<code>getCandidateConfigurations</code>方法，通过方法注释了解到，其返回一个自动配置类的类名列表，方法调用了<code>loadFactoryNames</code>方法，查看该方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">			AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">		List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(</span><br><span class="line">				getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());</span><br><span class="line">		Assert.notEmpty(configurations,</span><br><span class="line">				<span class="string">"No auto configuration classes found in META-INF/spring.factories. If you "</span></span><br><span class="line">						+ <span class="string">"are using a custom packaging, make sure that file is correct."</span>);</span><br><span class="line">		<span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上面的代码可以看到自动配置器会根据传入的<code>factoryClass.getName()</code>到项目系统路径下所有的<code>spring.factories</code>文件中找到相应的key，从而加载里面的类。我们就选取这个<code>mybatis-spring-boot-autoconfigure</code>下的<code>spring.factories</code>文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration</span><br></pre></td></tr></table></figure>
<p>进入<code>org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration</code>中，主要看一下类头：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@org</span>.springframework.context.annotation.Configuration</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123; SqlSessionFactory.class, SqlSessionFactoryBean.class &#125;)</span><br><span class="line"><span class="meta">@ConditionalOnBean</span>(DataSource.class)</span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(MybatisProperties.class)</span><br><span class="line"><span class="meta">@AutoConfigureAfter</span>(DataSourceAutoConfiguration.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisAutoConfiguration</span></span></span><br></pre></td></tr></table></figure>
<p>发现Spring的<code>@Configuration</code>，俨然是一个通过注解标注的springBean，继续向下看，</p>
<p><code>@ConditionalOnClass({ SqlSessionFactory.class, SqlSessionFactoryBean.class})</code>这个注解的意思是：当存在SqlSessionFactory.class, SqlSessionFactoryBean.class这两个类时才解析MybatisAutoConfiguration配置类，否则不解析这一个配置类，make sence，我们需要mybatis为我们返回会话对象，就必须有会话工厂相关类。</p>
<p><code>@CondtionalOnBean(DataSource.class)</code>：只有处理已经被声明为bean的dataSource。</p>
<p><code>@ConditionalOnMissingBean(MapperFactoryBean.class)</code>这个注解的意思是如果容器中不存在name指定的bean则创建bean注入，否则不执行（该类源码较长，篇幅限制不全粘贴）</p>
<p>以上配置可以保证<code>sqlSessionFactory</code>、<code>sqlSessionTemplate</code>、<code>dataSource</code>等mybatis所需的组件均可被自动配置，<code>@Configuration</code>注解已经提供了Spring的上下文环境，所以以上组件的配置方式与Spring启动时通过<code>mybatis.xml</code>文件进行配置起到一个效果。通过分析我们可以发现，只要一个基于SpringBoot项目的类路径下存在<code>SqlSessionFactory.class</code>, <code>SqlSessionFactoryBean.class</code>，并且容器中已经注册了dataSourceBean，就可以触发自动化配置，意思说我们只要在maven的项目中加入了mybatis所需要的若干依赖，就可以触发自动配置，但引入mybatis原生依赖的话，每集成一个功能都要去修改其自动化配置类，那就得不到开箱即用的效果了。所以Spring-boot为我们提供了统一的starter可以直接配置好相关的类，触发自动配置所需的依赖(mybatis)如下：</p>
<p>这里是截取的<code>mybatis-spring-boot-starter</code>的源码中<code>pom.xml</code>文件中所有依赖：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mybatis-spring-boot-autoconfigure&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<p>可以看到其中<code>mybatis-spring-boot-autoconfigure</code>就是配置文件，实现开箱即用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration</span><br></pre></td></tr></table></figure></p>

            

        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">TAGGED IN</span><br/>
                
    <a class="tag tag--primary tag--small t-link" href="/tags/FrameWork/">FrameWork</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/09/18/Data-Structure-Array/" data-tooltip="Data Structure Array" aria-label="PREVIOUS: Data Structure Array">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/08/02/Multithreading/" data-tooltip="Multithreading" aria-label="NEXT: Multithreading">
                
                    <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2019 Eddie Lee. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/09/18/Data-Structure-Array/" data-tooltip="Data Structure Array" aria-label="PREVIOUS: Data Structure Array">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/08/02/Multithreading/" data-tooltip="Multithreading" aria-label="NEXT: Multithreading">
                
                    <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                <div id="share-options-bar" class="share-options-bar" data-behavior="4">
    <i id="btn-close-shareoptions" class="fa fa-times"></i>
    <ul class="share-options">
        
    </ul>
</div>

            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/alan-walker.jpg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">Eddie Lee</h4>
        
            <div id="about-card-bio"><p>Once work as assistant teacher, and now in LN bld Technology Co. Ltd</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Developer</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                LN
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-vufjrm3fmbuttogo1hxuu0w9w0sesk5iyysjuguc2hdhufot9szxg8twijry.min.js"></script>
<!--SCRIPTS END-->

    



    </body>
</html>
